% this is to aggregate statistics for the third layer and prepare it for
% optimization function
% triples should look like that: left, middle, right

function [triplesHor] = Aggregate_3Layer(statistics, nClusters, n2Clusters, curTS) 
     
    % [el_cent    el_left depth_left,  el_right depth_right] ->  [el_left  el_cent  el_right]    

    % now we do not care about depths
    cols = [1,2,4];
    statistics = statistics(:, cols);
    triplesHor = zeros(n2Clusters, n2Clusters, n2Clusters); % x-direction

    for i = 1:curTS
        curline = statistics(i,:);
        % left center right
        triplesHor(curline(5), curline(1), curline(3))  = triplesHor(curline(5), curline(1), curline(3)) + 1;
        %top center bottoom
        if mod(i,200000) == 0
            i
        end
    end
    
    table = zeros(2,n2Clusters);
    for i = 1:n2Clusters
        [clusterX, clusterY] = compute2derivatives(i, nClusters);
        table(1,i) = clusterX;
        table(2,i) = clusterY;
    end
    
    ind = 0;
    adopted = [];

    X = zeros(curTS,6);
    frequencies = zeros(curTS,1);

    for i = 1:81
        for j = 1:81
            for k = 1:81
                if triples(i,j,k) > 1
                    ind = ind + 1;
                    X(ind,1) = table(1, i);
                    X(ind,2) = table(2, i); % left
                    X(ind,3) = table(1, j);
                    X(ind,4) = table(2, j); % center
                    X(ind,5) = table(1, k);
                    X(ind,6) = table(2, k); % right
                    frequencies(ind) = triples(i,j,k); 
                end
            end
        end
    end

    % initialization
    X = X(1:ind, :);
    frequencies = frequencies(1:ind);
    
end

