% This is a script to learn the entire 3D compositional hierarchy

% dataSetNumber 
% for Aim@Shape dataSetNumber = 1;
% for Washington dataSetNumber = 2;
% for Vladislav's_STD dataSetNumber = 3;
% grasping dataset dataSetNumber = 4;


% partSelectionMethod
% for LibHob-motivated partSelectionMethod = 1 
% for optimization-based partSelectionMethod = 2

% abstractionLevel = 1, 2  - grammar-based abstraction mechanisms
% abstractionLevel =  3 -  abstraction based on distance measure from isodata algorithm


function [] = learnHierarchy()

dataSetNumber = 3;
dataSetNames{1} = 'Aim@Shape';
dataSetNames{2} = 'Washington';
dataSetNames{3} = 'Vladislav_STD';

partSelectionMethod = 1;
nClusters = 9;

n2Clusters = nClusters^2;

% matlabpool open 4 % for parallel computing

if partSelectionMethod == 1
    abstractionLevel = 3;
    meargeThresh3 = sqrt(2) - 0.01;  % sqrt(2) are not mearged
    meargeThresh4 = sqrt(3) - 0.01;
elseif partSelectionMethod == 2
    
    % parameters for the different layers
    alphaParam = [0, 0, 0, 0];
    betaParam =  [0, 0, 1.5, 1.0];
    gammaParam = [0, 0, 0.33, 1.0];
end

% define folders configuration
root = '/home/vvk201/LibHoP3D/'; % 'D:/3D/LibHoP3D/'; 
addPaths(root);

depthPathDefault = '';


%% define the input data
if dataSetNumber == 1
    depthPath = '/home/vvk201/1T'; %'D:\3D\Input Data\Images for categorization\1T';     
elseif dataSetNumber == 2
    depthPath = '/home/vvk201/Wash-rgbd-dataset_0004';  %'/home/vvk201/Wash-rgbd-dataset'; 
elseif dataSetNumber == 3
    depthPath = '/home/vvk201/Vladislav_STD_400';
end


%% define output file names

dsN = num2str(dataSetNumber);
nCl = num2str(nClusters);

if partSelectionMethod == 1
    aL = num2str(abstractionLevel);
end

% files for the raw statistics
statistics1Layer = [root, 'statistics/statistics_1_', dsN, '_', nCl, '.mat'];
statistics3Layer = [root, 'statistics/statistics_3_', dsN, '_', nCl, '.mat'];
statistics4Layer = [root, 'statistics/statistics_4_', dsN, '_', nCl, '.mat'];
statistics5Layer = [root, 'statistics/statistics_5_', dsN, '_', nCl, '.mat'];
statistics6Layer = [root, 'statistics/statistics_6_', dsN, '_', nCl, '.mat'];

% files for the sieved statistics
statistics1LayerSieved = [root, 'statistics/statisticsSieved_1_', dsN, '_', nCl, '.mat'];
statistics3LayerSieved = [root, 'statistics/statisticsSieved_3_', dsN, '_', nCl, '.mat'];
statistics4LayerSieved = [root, 'statistics/statisticsSieved_4_', dsN, '_', nCl, '.mat'];
statistics5LayerSieved = [root, 'statistics/statisticsSieved_5_', dsN, '_', nCl, '.mat'];
statistics6LayerSieved = [root, 'statistics/statisticsSieved_6_', dsN, '_', nCl, '.mat'];

% files for the Aggregated statistics
statistics1LayerAggregated = [root, 'statistics/statisticsAggregated_1_', dsN, '_', nCl, '.mat'];
statistics3LayerAggregated = [root, 'statistics/statisticsAggregated_3_', dsN, '_', nCl, '.mat'];
statistics4LayerAggregated = [root, 'statistics/statisticsAggregated_4_', dsN, '_', nCl, '.mat'];
statistics5LayerAggregated = [root, 'statistics/statisticsAggregated_5_', dsN, '_', nCl, '.mat'];
statistics6LayerAggregated = [root, 'statistics/statisticsAggregated_6_', dsN, '_', nCl, '.mat'];

% files for part selection results
parts3Layer = [root, 'statistics/partsSelectionResults_3_', dsN, '_', nCl, '_a', aL, '.mat'];
parts4Layer = [root, 'statistics/partsSelectionResults_4_', dsN, '_', nCl, '_a', aL, '.mat'];
parts5Layer = [root, 'statistics/partsSelectionResults_5_', dsN, '_', nCl, '_a', aL, '.mat'];
parts6Layer = [root, 'statistics/partsSelectionResults_6_', dsN, '_', nCl, '_a', aL, '.mat'];

% files for overall coverage
coverageOverall3Layer = [root, 'statistics/coverageOverall_3_', dsN, '_', nCl, '_a', aL, '.mat'];
coverageOverall4Layer = [root, 'statistics/coverageOverall_4_', dsN, '_', nCl, '_a', aL, '.mat'];
coverageOverall5Layer = [root, 'statistics/coverageOverall_5_', dsN, '_', nCl, '_a', aL, '.mat'];
coverageOverall6Layer = [root, 'statistics/coverageOverall_6_', dsN, '_', nCl, '_a', aL, '.mat'];

% files for the
abstractionTable3Layer = [root, 'statistics/abstractionTable_3_', dsN, '_', nCl, '_a', aL, '.mat'];
abstractionTable4Layer = [root, 'Wash-rgbd-dataset_layer3_0004statistics/abstractionTable_4_', dsN, '_', nCl, '_a', aL, '.mat'];
abstractionTable5Layer = [root, 'statistics/abstractionTable_5_', dsN, '_', nCl, '_a', aL, '.mat'];
abstractionTable6Layer = [root, 'statistics/abstractionTable_6_', dsN, '_', nCl, '_a', aL, '.mat'];

% files for layer visualization
fileForVisualization3Layer = [root, 'statistics/fileForVisualization_3_', dsN, '_', nCl, '.mat'];
fileForVisualization4Layer = [root, 'statistics/fileForVisualization_4_', dsN, '_', nCl, '.mat'];
fileForVisualization5Layer = [root, 'statistics/fileForVisualization_5_', dsN, '_', nCl, '.mat'];
fileForVisualization6Layer = [root, 'statistics/fileForVisualization_6_', dsN, '_', nCl, '.mat'];

% folders with visualized vocabulary
diskFolder = '/home/vvk201/Visualized vocabulary/';
folderFor3Layer = [diskFolder, dataSetNames{dataSetNumber},'/3_layer/'];
folderFor4Layer = [diskFolder, dataSetNames{dataSetNumber},'/4_layer/'];
folderFor5Layer = [diskFolder, dataSetNames{dataSetNumber},'/5_layer/'];
folderFor6Layer = [diskFolder, dataSetNames{dataSetNumber},'/6_layer/'];

% conversionTable
conversionTable3to1 = [root, 'statistics/conversionTable3to1_', dsN, '_', nCl, '_a', aL, '.mat'];
conversionTable4to1 = [root, 'statistics/conversionTable4to1_', dsN, '_', nCl, '_a', aL, '.mat'];
conversionTable5to1 = [root, 'statistics/conversionTable5to1_', dsN, '_', nCl, '_a', aL, '.mat'];
conversionTable6to1 = [root, 'statistics/conversionTable6to1_', dsN, '_', nCl, '_a', aL, '.mat'];

%% define all parameters here

fileListPrecomputed = false;
is_subset = false; % whether we shall use all files for learning

% define the subset length
if dataSetNumber == 1 || dataSetNumber == 3
    subset_len = 400; % how much shall we use for training
    subsetPercent = 1.0; % not used
elseif dataSetNumber == 2
    subset_len = 1;
    subsetPercent = 1.0; % what percent from each folder to use
end

[dxKernel, combs, largestLine, sigma, sigmaKernelSize, isErrosion, discRadius, is_guided, r_guided, eps, ...
    is_mask_extended, maxExtThresh1, maxExtThresh2] = loadFilteringParameters(dataSetNumber);

% define parameters for inhibition
% min [error + wOverlap * overlap - wCoverage*coverage ]
if dataSetNumber == 1 || dataSetNumber == 3
    wCoverage = 0.25;
    wOverlap = 0.4;
elseif dataSetNumber == 2    
    wCoverage = 3.25;
    wOverlap = 0.52;
end

%% Define what we have to learn

is_first_layer = false; % computes cluster centres, thresh and clusterSizes
is_third_layer = false;  % learns the first layer
is_4th_layer = true;
is_5th_layer = false; 
is_6th_layer = false; 

is_statistics3_collected = true;
is_statistics4_collected = false;
is_statistics5_collected = false;
is_statistics6_collected = false;

is_statistics3_sieved = true;
is_statistics4_sieved = false;
is_statistics5_sieved = false;
is_statistics6_sieved = false;

is_statistics3_aggregated = true;
is_statistics4_aggregated = false;
is_statistics5_aggregated = true;
is_statistics6_aggregated = true;

is_partSelectionDone3 = false;
is_partSelectionDone4 = false;
is_partSelectionDone5 = true;
is_partSelectionDone6 = true;

% do we want to visualize the layer
visualizeLayer_3 = true;
visualizeLayer_4 = false;
visualizeLayer_5 = false;
visualizeLayer_6 = false;

%% here we define the first layer quantiles (bins of the first layer)

[quantilesFirst] = defineFirstLayerQuantiles(nClusters, dataSetNumber, is_guided);

%% creating a filelist here

if dataSetNumber == 1 || dataSetNumber == 3
    [list_depth, lenF] = extractFileList(fileListPrecomputed, depthPath, depthPathDefault, is_subset, subset_len);
    list_mask = [];
elseif dataSetNumber == 2
    [list_depth, list_mask, ~, lenF] = extractFileListWashington(fileListPrecomputed, depthPath, depthPathDefault, is_subset, subsetPercent);
end

% %  downsampling (if necessary)
% if dataSetNumber == 1 || dataSetNumber == 3
%     is_downsampling = true;
%     dowsample_rate = 1.4;
% elseif dataSetNumber == 2    
%     is_downsampling = true;
%     dowsample_rate = 2.5;
% end
% 
% upsampleImages(list_depth, list_mask, lenF, is_downsampling, dowsample_rate); % to be done only once!

is_downsampling = false;
dowsample_rate = 1;

% fieldSize = [17, 5, 71];  % x, y and z directions
% [coverageOverall, areaOverall] = ProjectAllStatistics3(statistics3LayerSieved, statistics3LayerAggregated, fieldSize, ...
%                                                        list_depth, list_mask, lenF, dataSetNumber);
% ratio = coverageOverall/areaOverall;
% save(coverageOverall3Layer,  'coverageOverall');



%% learn the first layer

if is_first_layer  % here we learn the first layer parameters
    disp('Calibration of the first layer parameters...');

    [cluster1Centres, cluster1Lengths, thresh] = learnFirstLayer(list_depth, list_mask, sigma, sigmaKernelSize, dxKernel, isErrosion, discRadius, ...
                      nClusters, is_downsampling, dowsample_rate, quantilesFirst, dataSetNumber,is_guided, r_guided, eps, ...
                      is_mask_extended, maxExtThresh1, maxExtThresh2);

    save(statistics1Layer,  'cluster1Centres', 'cluster1Lengths', 'thresh', 'nClusters', 'dataSetNumber');
end

% outFolder = '/home/vvk201/1LayerWash/';
% 
% applyFirstLayer(list_depth, list_mask, lenF, statistics1Layer, outFolder, sigma, sigmaKernelSize, ...
%                                 dxKernel, isErrosion, discRadius, is_guided, r_guided, eps,  is_mask_extended, maxExtThresh1, maxExtThresh2);



%% learn the third layer

if is_third_layer  % here we learn the third layer of the hierarchy
    
    disp('Learning of the third layer ...');
    % we have to perform the following procedures
    
    if ~is_first_layer
        % read the first layer
        load(statistics1Layer);
    end
    
    %load('displacements_Layers3_4.mat');
    load('settings/displacements_Layer3.mat');
    numDisps = size(displacements, 1);     % number of displacements
    fieldSize = [17, 5, 71];  % x, y and z directions
    quant = 0.06;
    iterations = 300;
    depthStep = thresh/4;
    
    
    if ~is_statistics3_collected
        [outputStatistics, outputCoords, curTS] = CollectStats_3_Layer(list_depth, list_mask, lenF, sigma, sigmaKernelSize, dxKernel, isErrosion, discRadius, nClusters, ...
                                                        cluster1Centres, cluster1Lengths, thresh, combs, largestLine, displacements, numDisps, ... 
                                                        wCoverage, wOverlap, fieldSize, depthStep, is_downsampling, dowsample_rate, dataSetNumber, ...
                                                        is_guided, r_guided, eps,  is_mask_extended, maxExtThresh1, maxExtThresh2);

        save(statistics3Layer, 'outputStatistics', 'outputCoords');
    end
    
    if ~is_statistics3_sieved 
    
        load(statistics3Layer);
        statistics = outputStatistics;
        clear('outputStatistics');
        curTS = size(statistics, 1);
        numDisps = 2;

        % for spead up reasons we sort statistics by the first column (central element)
        [~, order] = sort(statistics(:,1));
        statistics = statistics(order,:);
        outputCoords = outputCoords(order,:);
        clear('order');

        % compute the most frequent pairs
        thresh3Pair = 0.02 * lenF;
        [tablePairs, numPairs] = Learn3Pairs(statistics, curTS, n2Clusters, thresh3Pair, numDisps);

        % filter out rows with the least frequent pairs. those pairs with less than thresh3Pair occurrances will be filtered out
        [ind, statistics, curTS] = Sieve3Pairs(statistics, curTS, tablePairs, numDisps);
        outputCoords = outputCoords(ind, :);

        % now we have to measure depth and eliminate rows with depth discontinuities
        [cluster3Depths] = compute3Depths(statistics, n2Clusters, quant, numDisps);

        % now we have to filter out the depths with discontinuity
        [ind, statistics, curTS] = Sieve3PairsD(statistics, curTS, cluster3Depths, numDisps);
        outputCoords = outputCoords(ind,:);
        
        save(statistics3LayerSieved, 'statistics', 'cluster3Depths', 'outputCoords');
        
    else

        load(statistics3LayerSieved);  %  variable statistics should be read
        curTS = size(statistics, 1);
    end
    
    % aggregate statistics and prepare it to be fed to the optimization
    % function
    
    if ~is_statistics3_aggregated % aggregate statistics
        
        sieve_thresh = 3;
        [X, frequencies, curTS, triples] = Aggregate_3Layer(statistics, n2Clusters, curTS, sieve_thresh);
        
        % sieve 'statistics' and 'outputCoords' once again
        [ind, statistics] = Sieve3afterAggregation(statistics, triples, sieve_thresh, X);
        outputCoords = outputCoords(ind, :);  
        
        save(statistics3LayerSieved, 'statistics', 'cluster3Depths', 'outputCoords');
        save(statistics3LayerAggregated, 'X' ,'frequencies', 'curTS', 'triples');
    end
    
    if ~is_partSelectionDone3
        if partSelectionMethod == 1

            checkImages(list_depth, lenF); % makes images in the folder 3 channels ones

            [triples3Out, coverageOut, n3Clusters] = partSelectionNew(nClusters, n2Clusters, statistics3LayerSieved, statistics3LayerAggregated, ...
                                     dataSetNumber, fieldSize, list_depth, lenF, abstractionLevel, abstractionTable3Layer, meargeThresh3, ...
                                     iterations, 3, []);
            save(parts3Layer, 'triples3Out', 'coverageOut', 'n3Clusters', 'abstractionLevel');
                         

        elseif partSelectionMethod == 2

            load(statistics3LayerSieved);    
            load(statistics3LayerAggregated);

            [triples3Out] = Optimization_layer3(X, frequencies, triples, nClusters, alphaParam(3), betaParam(3), gammaParam(3), subset_len); % this is the main procedure
            save('statistics/layer3.mat', 'triples3Out');

            n3Clusters = size(triples3Out, 1);
            
        end
    end
    
    % store the visualization of the vocabulary to the folder
    
    if visualizeLayer_3
        
        load(parts3Layer);                 % 'triples3Out', 'coverageOut',    'n3Clusters'
        load(statistics3LayerSieved);      %  'statistics', 'cluster3Depths', 'outputCoords'
        
        n3Clusters = 150;
        
        % prepare data for visualization (convert to the right format)
        [triple3OutDepth] = store3Layer(triples3Out, cluster3Depths, n3Clusters, nClusters, partSelectionMethod);
        save(fileForVisualization3Layer, 'triple3OutDepth');
        
        fieldSize = [17, 17, 71];
        % load(fileForVisualization3Layer);

        % restrict selected set of parts
        lenSelected = 0.8 * lenF;

        idx = coverageOut(coverageOut > lenSelected);
        % n3Clusters = 150; %length(idx);   %size(triple3OutDepth,1);
        displ = 6;
        
        save(parts3Layer, 'triples3Out', 'coverageOut', 'n3Clusters', 'abstractionLevel');

        [is_ok] = layer_3_demonstrator(triple3OutDepth, displ, nClusters, n3Clusters, folderFor3Layer, fieldSize, depthStep, cluster1Centres);
    end
    
end








%% learn the 4th layer

if is_4th_layer

    disp('Learning of the 4th layer ...');

    if ~is_first_layer % read the first layer
        load(statistics1Layer);
    end

    if ~is_third_layer % read the third layer
        load(parts3Layer); % 'triples3Out', 'coverageOut', 'n3Clusters', 'abstractionLevel');  
    end

    load('displacements_Layer4.mat');   % 'displacements'
    numDisps = size(displacements, 1); 
    displacement34 = 6;
    fieldSize = [17, 17, 71];
    depthStep = thresh/4;
    quant = 0.08;
    maxDist = 2;
    iterations = 600;
    
    elPath = '/home/vvk201/Vladislav_STD_layer3_400';
    strFolderLen = length(depthPath);
    
    list_els = list_depth;
    for i = 1:lenF
        str = list_els{i};
        str = [elPath ,str(strFolderLen + 1:end)];
        list_els{i} = str;
    end
    
    if ~is_statistics4_collected
        [outputStatistics, outputCoords, curTS] = CollectStats_NextLayers(list_els, list_depth, list_mask, lenF, sigma, sigmaKernelSize, dxKernel, isErrosion, discRadius, nClusters, ...
                                displacements, numDisps, displacement34, ... 
                                wCoverage, wOverlap, fieldSize, depthStep, is_downsampling, dowsample_rate, dataSetNumber, ...
                                is_guided, r_guided, eps,  is_mask_extended, maxExtThresh1, maxExtThresh2);

        save(statistics4Layer, 'outputStatistics', 'outputCoords');
    end

    if ~is_statistics4_sieved 
    
        load(statistics4Layer);
        statistics = outputStatistics;
        clear('outputStatistics');
        curTS = size(statistics, 1);
        numDisps = 2;

        % for spead up reasons we sort statistics by t3he first column (central element)
        [~, order] = sort(statistics(:,1));
        statistics = statistics(order,:);
        outputCoords = outputCoords(order,:);
        clear('order');

        % compute the most frequent pairs
        thresh4Pair = 0.03 * lenF;
        [tablePairs, numPairs] = Learn3Pairs(statistics, curTS, n3Clusters, thresh4Pair, numDisps);

        % filter out rows with the least frequent pairs. those pairs with less than thresh3Pair occurrances will be filtered out
        [ind, statistics, curTS] = Sieve3Pairs(statistics, curTS, tablePairs, numDisps);
        outputCoords = outputCoords(ind, :);

        % now we have to measure depth and eliminate rows with depth discontinuities
        [cluster4Depths] = compute3Depths(statistics, n3Clusters, quant, numDisps);

        % now we have to filter out the depths with discontinuity
        [ind, statistics, curTS] = Sieve3PairsD(statistics, curTS, cluster4Depths, numDisps);
        outputCoords = outputCoords(ind,:);
        
        save(statistics4LayerSieved, 'statistics', 'cluster4Depths', 'outputCoords');       
    else
        load(statistics4LayerSieved);  %  variable statistics should be read
        curTS = size(statistics, 1);
    end
    
    if ~is_statistics4_aggregated % aggregate statistics
        
        sieve_thresh = 3;
        [X, frequencies, curTS, triples] = Aggregate_3Layer(statistics, n3Clusters, curTS, sieve_thresh);
        
        % sieve 'statistics' and 'outputCoords' once again
        [ind, statistics] = Sieve3afterAggregation(statistics, triples, sieve_thresh, X);
        outputCoords = outputCoords(ind, :);  
        
        save(statistics4LayerSieved, 'statistics', 'cluster4Depths', 'outputCoords');
        save(statistics4LayerAggregated, 'X' ,'frequencies', 'curTS', 'triples');
    end
    
    if ~is_partSelectionDone4
        if partSelectionMethod == 1 % libhop-based style 
            
            checkImages(list_depth, lenF); % makes images in the folder 3 channels ones

            [triples4Out, coverageOut, n4Clusters] = partSelectionNew(nClusters, n2Clusters, statistics4LayerSieved, statistics4LayerAggregated, ...
                                     dataSetNumber, fieldSize, list_depth, lenF, abstractionLevel, abstractionTable3Layer, meargeThresh4, ...
                                     iterations, 4, fileForVisualization3Layer);
            save(parts4Layer, 'triples4Out', 'coverageOut', 'n4Clusters', 'abstractionLevel');
            
            
        elseif partSelectionMethod == 2
            
            [triples4Out] = Optimization_layer4(X, frequencies, triples3Out, triples4, nClusters, n3Clusters, maxDist, subset_len, alphaParam(4), betaParam(4), gammaParam(4));
            n4Clusters = size(triples4Out, 1);
            save('statistics/layer4Wash1.mat', 'triples4Out');
        end
    end
    
    if visualizeLayer_4
        
        load(parts4Layer);                 % 'triples4Out', 'coverageOut',    'n4Clusters'
        load(statistics4LayerSieved);      %  'statistics', 'cluster3Depths', 'outputCoords'
        
        n4Clusters = 320;
        
        % prepare data for visualization (convert to the right format)
        [triple4OutDepth] = store3Layer(triples4Out, cluster4Depths, n4Clusters, nClusters, partSelectionMethod);
        save(fileForVisualization4Layer, 'triple4OutDepth');
        
        fieldSize = [17, 17, 71];
        % load(fileForVisualization3Layer);

        % restrict selected set of parts
        lenSelected = 0.8 * lenF;

        idx = coverageOut(coverageOut > lenSelected);
        % n3Clusters = 150; %length(idx);   %size(triple3OutDepth,1);
        displ = 6;
        
        save(parts4Layer, 'triples3Out', 'coverageOut', 'n3Clusters', 'abstractionLevel');

        [is_ok] = layer_4_demonstrator(triple3OutDepth, displ, nClusters, n3Clusters, folderFor3Layer, fieldSize, depthStep, cluster1Centres);
    end
  


    a = 2;


end   



% matlabpool close 

