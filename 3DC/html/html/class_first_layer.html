<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>3DHierarchy: FirstLayer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">3DHierarchy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_first_layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FirstLayer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_first_layer_8h_source.html">FirstLayer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c91a3e201cb46ef6f597cefe87b35a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a2c91a3e201cb46ef6f597cefe87b35a0">FirstLayer</a> ()</td></tr>
<tr class="memdesc:a2c91a3e201cb46ef6f597cefe87b35a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a2c91a3e201cb46ef6f597cefe87b35a0">More...</a><br/></td></tr>
<tr class="separator:a2c91a3e201cb46ef6f597cefe87b35a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cec9185f94b6bf4c99b6eda97e4d73b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a6cec9185f94b6bf4c99b6eda97e4d73b">~FirstLayer</a> ()</td></tr>
<tr class="memdesc:a6cec9185f94b6bf4c99b6eda97e4d73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a6cec9185f94b6bf4c99b6eda97e4d73b">More...</a><br/></td></tr>
<tr class="separator:a6cec9185f94b6bf4c99b6eda97e4d73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c046c60d3b3269e93955b07b15986b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#aa6c046c60d3b3269e93955b07b15986b">matrixToTxtFile</a> (const Mat &amp;m, string filename)</td></tr>
<tr class="memdesc:aa6c046c60d3b3269e93955b07b15986b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a matrix to the text file.  <a href="#aa6c046c60d3b3269e93955b07b15986b">More...</a><br/></td></tr>
<tr class="separator:aa6c046c60d3b3269e93955b07b15986b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e6821bc705c01d174685335b20322a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a14e6821bc705c01d174685335b20322a">vectorToTxtFile</a> (const vector&lt; vector&lt; double &gt; &gt; data, string filename)</td></tr>
<tr class="memdesc:a14e6821bc705c01d174685335b20322a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a vector of vectors to the text file.  <a href="#a14e6821bc705c01d174685335b20322a">More...</a><br/></td></tr>
<tr class="separator:a14e6821bc705c01d174685335b20322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a31ab9f8833c145dc2b94cba91f3d70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a7a31ab9f8833c145dc2b94cba91f3d70">vectorToTxtFile</a> (const vector&lt; vector&lt; float &gt; &gt; data, string filename)</td></tr>
<tr class="memdesc:a7a31ab9f8833c145dc2b94cba91f3d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a vector of vectors to the text file.  <a href="#a7a31ab9f8833c145dc2b94cba91f3d70">More...</a><br/></td></tr>
<tr class="separator:a7a31ab9f8833c145dc2b94cba91f3d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8577b4d6cb790edc7bd04446727f28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#aba8577b4d6cb790edc7bd04446727f28">calcGradient</a> (const Mat &amp;m, Mat &amp;gradX, Mat &amp;gradY, Mat &amp;gradOrient, Mat &amp;gradMagnit)</td></tr>
<tr class="memdesc:aba8577b4d6cb790edc7bd04446727f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient of the depth image.  <a href="#aba8577b4d6cb790edc7bd04446727f28">More...</a><br/></td></tr>
<tr class="separator:aba8577b4d6cb790edc7bd04446727f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a88c95e693b614a27be5bb5c536d41c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a2a88c95e693b614a27be5bb5c536d41c">calcHistogram</a> (const Mat &amp;m, Mat &amp;hist)</td></tr>
<tr class="memdesc:a2a88c95e693b614a27be5bb5c536d41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates histogram of the depth image.  <a href="#a2a88c95e693b614a27be5bb5c536d41c">More...</a><br/></td></tr>
<tr class="separator:a2a88c95e693b614a27be5bb5c536d41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485d0275f548130fad99051cb8736dc5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a485d0275f548130fad99051cb8736dc5">calcColorMap</a> (const Mat &amp;m, Mat &amp;colorMap)</td></tr>
<tr class="memdesc:a485d0275f548130fad99051cb8736dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates color mapping for displaying depth images.  <a href="#a485d0275f548130fad99051cb8736dc5">More...</a><br/></td></tr>
<tr class="separator:a485d0275f548130fad99051cb8736dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62260984a4e3d9c473234e4b48610974"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a62260984a4e3d9c473234e4b48610974">calcRecptField</a> (const Mat &amp;m, Mat &amp;recept, int recFieldSize)</td></tr>
<tr class="memdesc:a62260984a4e3d9c473234e4b48610974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates receptive field without overlap.  <a href="#a62260984a4e3d9c473234e4b48610974">More...</a><br/></td></tr>
<tr class="separator:a62260984a4e3d9c473234e4b48610974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf9ba54ebcb3d63a6fe84d5dc4d50dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a6cf9ba54ebcb3d63a6fe84d5dc4d50dc">segmentParts</a> (vector&lt; vector&lt; double &gt; &gt; &amp;data, Mat &amp;output, int layerNum, int difference)</td></tr>
<tr class="memdesc:a6cf9ba54ebcb3d63a6fe84d5dc4d50dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segments parts according to distance measure.  <a href="#a6cf9ba54ebcb3d63a6fe84d5dc4d50dc">More...</a><br/></td></tr>
<tr class="separator:a6cf9ba54ebcb3d63a6fe84d5dc4d50dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0013ac908aa60b6fbb791998f845a5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#ac0013ac908aa60b6fbb791998f845a5c">calcDistanceMeasure</a> (const Mat &amp;m, vector&lt; vector&lt; double &gt; &gt; &amp;data, int recFieldSize)</td></tr>
<tr class="memdesc:ac0013ac908aa60b6fbb791998f845a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates distance between patches at the first layer.  <a href="#ac0013ac908aa60b6fbb791998f845a5c">More...</a><br/></td></tr>
<tr class="separator:ac0013ac908aa60b6fbb791998f845a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6b8fed0cde49a767acbc38dfa521f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a1c6b8fed0cde49a767acbc38dfa521f7">calcDistanceMeasureSec</a> (const Mat &amp;m, vector&lt; vector&lt; double &gt; &gt; &amp;data, int layerNum, int recFieldSize)</td></tr>
<tr class="memdesc:a1c6b8fed0cde49a767acbc38dfa521f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates distance between patches at the second layer and above.  <a href="#a1c6b8fed0cde49a767acbc38dfa521f7">More...</a><br/></td></tr>
<tr class="separator:a1c6b8fed0cde49a767acbc38dfa521f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5660027541994b18f6be950ff73bb403"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a5660027541994b18f6be950ff73bb403">precomputeDistance</a> (int layerNum, int recFieldSize)</td></tr>
<tr class="memdesc:a5660027541994b18f6be950ff73bb403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputes the distance between parts on arbitrary layer.  <a href="#a5660027541994b18f6be950ff73bb403">More...</a><br/></td></tr>
<tr class="separator:a5660027541994b18f6be950ff73bb403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9d6d5d83ef778ea076140cc9ecc9e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#abe9d6d5d83ef778ea076140cc9ecc9e2">calcRecptFieldOverlap</a> (const Mat &amp;mOrient, const Mat &amp;mMagnit, Mat &amp;recept, int recFieldSize)</td></tr>
<tr class="memdesc:abe9d6d5d83ef778ea076140cc9ecc9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates receptive field with overlap.  <a href="#abe9d6d5d83ef778ea076140cc9ecc9e2">More...</a><br/></td></tr>
<tr class="separator:abe9d6d5d83ef778ea076140cc9ecc9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc2aa2add70a95cab3e6d5c6bde6a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#abcfc2aa2add70a95cab3e6d5c6bde6a7">calcNormals</a> (const Mat &amp;gradX, const Mat &amp;gradY, Mat &amp;normals)</td></tr>
<tr class="memdesc:abcfc2aa2add70a95cab3e6d5c6bde6a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates normals using gradients calculated in X and Y direction.  <a href="#abcfc2aa2add70a95cab3e6d5c6bde6a7">More...</a><br/></td></tr>
<tr class="separator:abcfc2aa2add70a95cab3e6d5c6bde6a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b3d6af0b7196ef5478c45bbda9e97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a028b3d6af0b7196ef5478c45bbda9e97">calcNormalsPCA</a> (const Mat &amp;m, Mat &amp;normals, int recFieldSize)</td></tr>
<tr class="memdesc:a028b3d6af0b7196ef5478c45bbda9e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates normals using PCA.  <a href="#a028b3d6af0b7196ef5478c45bbda9e97">More...</a><br/></td></tr>
<tr class="separator:a028b3d6af0b7196ef5478c45bbda9e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5981a6b0f49fd66692da5001ff4b021"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#ae5981a6b0f49fd66692da5001ff4b021">calcDistanceMeasureNormals</a> (const Mat &amp;m, vector&lt; vector&lt; float &gt; &gt; &amp;data)</td></tr>
<tr class="memdesc:ae5981a6b0f49fd66692da5001ff4b021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates distance measure between normals.  <a href="#ae5981a6b0f49fd66692da5001ff4b021">More...</a><br/></td></tr>
<tr class="separator:ae5981a6b0f49fd66692da5001ff4b021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26c3c16c6dd6050d17ce6165ce58bef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#ad26c3c16c6dd6050d17ce6165ce58bef">calcDerivatives</a> (const Mat &amp;m, Mat &amp;gradX, Mat &amp;gradY, Mat &amp;gradXX, Mat &amp;gradYY, Mat &amp;gradXY, char kernelSize)</td></tr>
<tr class="memdesc:ad26c3c16c6dd6050d17ce6165ce58bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates discrete versions of derivatives using Sobel mask.  <a href="#ad26c3c16c6dd6050d17ce6165ce58bef">More...</a><br/></td></tr>
<tr class="separator:ad26c3c16c6dd6050d17ce6165ce58bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bfbc1a96cfb52b73594d57124e1bf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#ab2bfbc1a96cfb52b73594d57124e1bf3">calcHKmap</a> (const Mat &amp;gradX, const Mat &amp;gradY, const Mat &amp;gradXX, const Mat &amp;gradYY, const Mat &amp;gradXY, Mat &amp;H, Mat &amp;K, Mat &amp;HS, Mat &amp;KS, Mat &amp;HK)</td></tr>
<tr class="memdesc:ab2bfbc1a96cfb52b73594d57124e1bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates discrete versions of local surface curvature descriptor.  <a href="#ab2bfbc1a96cfb52b73594d57124e1bf3">More...</a><br/></td></tr>
<tr class="separator:ab2bfbc1a96cfb52b73594d57124e1bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7818bd290e7b21a32b3d150941ab55df"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_map&lt; int, Mat &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a7818bd290e7b21a32b3d150941ab55df">_layerMap</a></td></tr>
<tr class="memdesc:a7818bd290e7b21a32b3d150941ab55df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapping from Layer to Layer.  <a href="#a7818bd290e7b21a32b3d150941ab55df">More...</a><br/></td></tr>
<tr class="separator:a7818bd290e7b21a32b3d150941ab55df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f941b882ec8f2c8d92b454ec4114c0"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_map&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#a63f941b882ec8f2c8d92b454ec4114c0">_layerMapFrequency</a></td></tr>
<tr class="memdesc:a63f941b882ec8f2c8d92b454ec4114c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency of each part at each layer.  <a href="#a63f941b882ec8f2c8d92b454ec4114c0">More...</a><br/></td></tr>
<tr class="separator:a63f941b882ec8f2c8d92b454ec4114c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd09e90b6c65da988079abe99f3b5e34"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_map&lt; int, <br class="typebreak"/>
unordered_map&lt; int, int &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_first_layer.html#abd09e90b6c65da988079abe99f3b5e34">_layerDistance</a></td></tr>
<tr class="separator:abd09e90b6c65da988079abe99f3b5e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2c91a3e201cb46ef6f597cefe87b35a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FirstLayer::FirstLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a6cec9185f94b6bf4c99b6eda97e4d73b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FirstLayer::~FirstLayer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a485d0275f548130fad99051cb8736dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcColorMap </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>colorMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates color mapping for displaying depth images. </p>
<p>This method is map 16-bit image into color map for visualization purposes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">colorMap</td><td>storage for a histogram </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="ad26c3c16c6dd6050d17ce6165ce58bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcDerivatives </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradXX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradYY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradXY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>kernelSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates discrete versions of derivatives using Sobel mask. </p>
<p>The method allows to obtain discrete values of the derivates of the input image. Sobel mask was used, hence the scaling is performed after first derivative is obtained and passed to the second derivative. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">gradX</td><td>storage for calculated first derivative along X direction </td></tr>
    <tr><td class="paramname">gradY</td><td>storage for calculated first derivative along Y direction </td></tr>
    <tr><td class="paramname">gradXX</td><td>storage for calculated second derivative along X direction </td></tr>
    <tr><td class="paramname">gradYY</td><td>storage for calculated second derivative along Y direction </td></tr>
    <tr><td class="paramname">gradXY</td><td>storage for calculated mixed derivative first (X) second (Y) </td></tr>
    <tr><td class="paramname">kernelSize</td><td>size of the kernel used for derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="ac0013ac908aa60b6fbb791998f845a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcDistanceMeasure </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recFieldSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates distance between patches at the first layer. </p>
<p>This method allows to obtain the distances between all the patches of size (receptiveField x receptiveField)present in the image of the first layer. Only at the first layer calculation are performed on the on actual data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image of the selected layer) </td></tr>
    <tr><td class="paramname">data</td><td>storage for calculated distance measure for all the parts (output) </td></tr>
    <tr><td class="paramname">recFieldSize</td><td>size of the receptive field for the current layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="ae5981a6b0f49fd66692da5001ff4b021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcDistanceMeasureNormals </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; float &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates distance measure between normals. </p>
<p>Use this method together with <a class="el" href="class_first_layer.html#a028b3d6af0b7196ef5478c45bbda9e97" title="Calculates normals using PCA. ">calcNormalsPCA()</a>. This function calculate difference between all the patches of size (receptiveField x receptiveField) present in the image and computed by <a class="el" href="class_first_layer.html#a028b3d6af0b7196ef5478c45bbda9e97" title="Calculates normals using PCA. ">calcNormalsPCA()</a>. Distance is obtained as a dot product between two patches. The function is a resource consuming. While calculate all the possible combintations between parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (normals image) </td></tr>
    <tr><td class="paramname">data</td><td>storage for calculated distance measure for all the parts (output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a1c6b8fed0cde49a767acbc38dfa521f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcDistanceMeasureSec </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recFieldSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates distance between patches at the second layer and above. </p>
<p>Use this method together with precomputeDistance. This function calculate difference between all the patches of size (receptiveField x receptiveField) present in the image at the current layer and returns it to vector of vectors. Distances are measured for the parts projected to the first layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image of the selected layer) </td></tr>
    <tr><td class="paramname">data</td><td>storage for calculated distance measure for all the parts (output) </td></tr>
    <tr><td class="paramname">layerNum</td><td>number of layer which is currently processed </td></tr>
    <tr><td class="paramname">recFieldSize</td><td>size of the receptive field for the current layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="aba8577b4d6cb790edc7bd04446727f28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcGradient </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradOrient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>gradMagnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the gradient of the depth image. </p>
<p>This method is calculating the gradient of the image using SCHARR mask. Gradient orientation is calculated but not its magnitude. Method includes initial smoothing with Gaussian Filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">gradX</td><td>storage for gradient X-gradient </td></tr>
    <tr><td class="paramname">gradY</td><td>storage for gradient Y-gradient </td></tr>
    <tr><td class="paramname">gradOrient</td><td>storage for gradient orientation </td></tr>
    <tr><td class="paramname">gradMagnit</td><td>storage for gradient magnitude </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a2a88c95e693b614a27be5bb5c536d41c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcHistogram </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>hist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates histogram of the depth image. </p>
<p>This method is calculating the Histogram of the gradient. All the parameters are set using class variables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">hist</td><td>storage for a histogram </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="ab2bfbc1a96cfb52b73594d57124e1bf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcHKmap </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradXX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradYY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradXY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>HS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>KS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>HK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates discrete versions of local surface curvature descriptor. </p>
<p>Use this method together with <a class="el" href="class_first_layer.html#ad26c3c16c6dd6050d17ce6165ce58bef" title="Calculates discrete versions of derivatives using Sobel mask. ">calcDerivatives()</a>. The method allows to obtain Gaussian and mean curvature of the surfaces. These are the local measures of surface shape. Due to the computation of second derivativea they are very sensitive to noise. Intensive smoothing is required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">gradX</td><td>input first derivative along X direction </td></tr>
    <tr><td class="paramname">gradY</td><td>input first derivative along Y direction </td></tr>
    <tr><td class="paramname">gradXX</td><td>input second derivative along X direction </td></tr>
    <tr><td class="paramname">gradYY</td><td>input second derivative along Y direction </td></tr>
    <tr><td class="paramname">gradXY</td><td>input mixed derivative first (X) second (Y) </td></tr>
    <tr><td class="paramname">H</td><td>storage for computed values of mean curvature </td></tr>
    <tr><td class="paramname">K</td><td>storage for computed values of Gaussian curvature </td></tr>
    <tr><td class="paramname">HS</td><td>storage for computed signs of mean curvature </td></tr>
    <tr><td class="paramname">KS</td><td>storage for computed signs of Gaussian curvature </td></tr>
    <tr><td class="paramname">HK</td><td>storage for computed HK-map </td></tr>
    <tr><td class="paramname">kernelSize</td><td>size of the kernel used for derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="abcfc2aa2add70a95cab3e6d5c6bde6a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcNormals </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>gradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates normals using gradients calculated in X and Y direction. </p>
<p>It is not the best way of calculating normals. Not whole information is available since the projection from sphere into circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gradX</td><td>input matrix with calculated values of gradient in X direction </td></tr>
    <tr><td class="paramname">gradY</td><td>input matrix with calculated values of gradient in Y direction </td></tr>
    <tr><td class="paramname">normals</td><td>storage for calculated normals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a028b3d6af0b7196ef5478c45bbda9e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcNormalsPCA </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recFieldSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates normals using PCA. </p>
<p>This method uses PCA to obtain the proper values of normals. The normals are calculated using covariance matrix computed for the window on depth data. The vector associated with the smallest eigen value is the normal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">normals</td><td>storage for calculated normals </td></tr>
    <tr><td class="paramname">recFieldSize</td><td>size of the receptive field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a62260984a4e3d9c473234e4b48610974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcRecptField </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>recept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recFieldSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates receptive field without overlap. </p>
<p>Receptive field at the botom layer is calculated as a mean of values in the neighbourhood specified by the receptive field size. Border is replicated on the right and bottom part of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">recept</td><td>storage for an image after contraction </td></tr>
    <tr><td class="paramname">recFieldSize</td><td>size of the receptive field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="abe9d6d5d83ef778ea076140cc9ecc9e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::calcRecptFieldOverlap </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>mOrient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>mMagnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>recept</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recFieldSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates receptive field with overlap. </p>
<p>Receptive field at the botom layer is calculated as a median of values in the neighbourhood specified by the receptive field size. Border is replicated on the right and bottom part of the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input matrix (image) </td></tr>
    <tr><td class="paramname">recept</td><td>storage for an image after contraction </td></tr>
    <tr><td class="paramname">recFieldSize</td><td>size of the receptive field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="aa6c046c60d3b3269e93955b07b15986b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::matrixToTxtFile </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a matrix to the text file. </p>
<p>This method is storing a matrix in a text file in order to get better view at the exact values at certain locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>matrix to be stored in the text file </td></tr>
    <tr><td class="paramname">file</td><td>name of the text file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a5660027541994b18f6be950ff73bb403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::precomputeDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNum</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>recFieldSize</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precomputes the distance between parts on arbitrary layer. </p>
<p>The method allows to obtain ceratain speed up in calculating the distance between patches on the higher layers. Distances are measured for the parts projected to the first layer. Data are stored in the member variable layerDistance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerNum</td><td>number of layer which is currently processed </td></tr>
    <tr><td class="paramname">recFieldSize</td><td>size of the receptive field for the current layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a6cf9ba54ebcb3d63a6fe84d5dc4d50dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::segmentParts </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layerNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Segments parts according to distance measure. </p>
<p>Use this function together with calcDistanceMeasure. Segmentation is performed according to distance measure defined in calcDistanceMeasure. List of parts obtained from calcDistanceMeasure is stored in _parts[layerNumber][partNumber] temporary to count all the parts Store the relation on the current layer _layerMap[layerNumber][partNumber]; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>calculated distance measure for all the parts </td></tr>
    <tr><td class="paramname">output</td><td>storage for the image after segmentation </td></tr>
    <tr><td class="paramname">layerNum</td><td>number of layer which is currently processed </td></tr>
    <tr><td class="paramname">difference</td><td>threshold used for comparing similarity of parts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a14e6821bc705c01d174685335b20322a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::vectorToTxtFile </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a vector of vectors to the text file. </p>
<p>This method is storing a vector of vectors in a text file in order to get better view at the exact values at certain locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>vector to be stored in the text file </td></tr>
    <tr><td class="paramname">file</td><td>name of the text file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<a class="anchor" id="a7a31ab9f8833c145dc2b94cba91f3d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int FirstLayer::vectorToTxtFile </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; float &gt; &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a vector of vectors to the text file. </p>
<p>This method is storing a vector of vectors in a text file in order to get better view at the exact values at certain locations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>vector to be stored in the text file </td></tr>
    <tr><td class="paramname">file</td><td>name of the text file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success return </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="abd09e90b6c65da988079abe99f3b5e34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;unordered_map&lt;int, unordered_map&lt;int,int&gt; &gt; &gt; FirstLayer::_layerDistance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Member variable for storring the precalculated distances for each layer _layerDistance[layerNumber][firstPartNumber][secondPartNumber] = distance </p>

</div>
</div>
<a class="anchor" id="a7818bd290e7b21a32b3d150941ab55df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;unordered_map&lt;int,Mat&gt; &gt; FirstLayer::_layerMap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mapping from Layer to Layer. </p>

</div>
</div>
<a class="anchor" id="a63f941b882ec8f2c8d92b454ec4114c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;unordered_map&lt;int,int&gt; &gt; FirstLayer::_layerMapFrequency</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frequency of each part at each layer. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_first_layer_8h_source.html">FirstLayer.h</a></li>
<li>src/<a class="el" href="_first_layer_8cpp.html">FirstLayer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 12 2014 14:29:45 for 3DHierarchy by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
